= ESP32 Components documentation
:toc:
:toclevels: 3

WARNING: This documentation describes the current behavior of ESP32 components.
Internal APIs or hooks may evolve in the future.

== Conventions

=== GPIO constants
Most examples assume you use a `GPIO` helper enum/constants, e.g. `GPIO.GPIO32`.
Replace with raw pin numbers if your project does not use this helper.

=== Application hooks
Components register themselves to the framework in one of these lists:

* `App().update` for components that need periodic polling/dispatch in the main loop
* `App().on_frame_received` for components that react to incoming frames

=== Frames and slugs
Some components can be bound to incoming frame payloads via a `slug`.

* If `slug` is `None`, the component ignores frames.
* If `slug` is set, the component scans `frame.payload` and reacts when `payload.slug == slug`.
* If `on_payload_received` is provided, it is called first and you can override the default behavior.

Callback signature:
[,python]
----
def on_payload_received(component, payload):
    ...
----

---

== Button

The `Button` component listens to a physical button connected to a GPIO pin.
It automatically registers itself in the application update loop (`App().update`).

=== Wiring

|===
| ESP32 Pin | Button Pin

| GPIO (ex: GPIO32)
| One side of the button

| GND
| Other side of the button
|===

IMPORTANT: The button uses an internal `PULL_DOWN` resistor.
This means the GPIO reads `0` when released, and must be connected to **3.3V** when pressed
(e.g. button between GPIO and 3.3V, NOT between GPIO and GND).

=== Usage

[,python]
----
from src.components.button import Button
from src.utils.gpio import GPIO

button = Button(
    pin=GPIO.GPIO32,
    onPress=lambda: print("Button pressed"),
    onRelease=lambda: print("Button released")
)
----

=== Behavior

|===
| Event | Description

| `onPress`
| Called once when the button transitions from released to pressed

| `onRelease`
| Called once when the button transitions from pressed to released
|===

---

== Led

The `Led` component controls a single digital LED using a GPIO output.
It can also react to incoming frames if a `slug` is provided.

=== Wiring

|===
| ESP32 Pin | LED Pin

| GPIO (ex: GPIO2)
| LED anode (through a resistor)

| GND
| LED cathode
|===

IMPORTANT: Always use a current-limiting resistor (typically 220Ω – 330Ω).

=== Usage

[,python]
----
from src.components.led import Led
from src.utils.gpio import GPIO

led = Led(
    pin=GPIO.GPIO2
)

led.on()
led.off()
----

=== Frame-based control (optional)

If a `slug` is provided, the LED reacts automatically to incoming frames.

[,python]
----
led = Led(
    pin=GPIO.GPIO2,
    slug="status-led"
)
----

Default behavior when a matching payload is received:

* if `payload.datatype == "bool"`:
** `True` -> `led.on()`
** `False` -> `led.off()`

Override behavior with a callback:

[,python]
----
def on_payload_received(led, payload):
    # Example: invert logic
    if payload.datatype == "bool":
        led.off() if payload.value else led.on()

led = Led(
    pin=GPIO.GPIO2,
    slug="status-led",
    on_payload_received=on_payload_received
)
----

=== State

|===
| Property | Description

| `is_on`
| `True` when the LED is currently on, else `False`
|===

---

== LedStrip

The `LedStrip` component controls an addressable LED strip (NeoPixel / WS2812).
It listens to incoming frames to toggle the strip state.

=== Wiring

|===
| ESP32 Pin | Led Strip Pin

| GPIO (ex: GPIO25)
| DIN (Data In)

| 5V / 3.3V
| VCC (depending on strip model)

| GND
| GND
|===

IMPORTANT:
* Ensure common ground between ESP32 and the LED strip.
* Some strips require an external 5V power supply.
* Some 5V strips may require a level shifter on the data line for reliable operation.

=== Usage

[,python]
----
from src.components.led_strip import LedStrip
from src.utils.gpio import GPIO

strip = LedStrip(
    pin=GPIO.GPIO25,
    pixel_num=10
)

strip.on()      # fill with default color
strip.off()     # clear
strip.set_pixel(0, (255, 0, 0), show=True)
----

=== Default behavior

|===
| Action | Description

| `on(color=None)`
| Turns all pixels on using `color` or `default_color`

| `off()`
| Turns all pixels off (clears strip)

| `fill(color)`
| Updates internal pixels array (does not automatically show)

| `display()`
| Writes internal pixels array to the strip

| `set_pixel(i, color=None, show=False)`
| Sets one pixel to `color` (or default) and optionally displays

| `next_pixel(color=None, show=False)`
| Lights the next pixel with the given color (or default) and returns its index

| `previous_pixel(color=None, show=False)`
| Lights the previous pixel with the given color (or default) and returns its index
|===

=== Frame-based control (optional)

Bind the strip to a frame payload using a `slug`.

[,python]
----
strip = LedStrip(
    pin=GPIO.GPIO25,
    pixel_num=10,
    slug="main-strip"
)
----

Default behavior when a matching payload is received:

* if `payload.datatype == "bool"`:
** `True` -> `strip.on()`
** `False` -> `strip.off()`

Override behavior with a callback:

[,python]
----
def on_payload_received(strip, payload):
    # Example: change color based on a custom payload
    if payload.datatype == "bool":
        strip.on((0, 255, 0)) if payload.value else strip.off()

strip = LedStrip(
    pin=GPIO.GPIO25,
    pixel_num=10,
    slug="main-strip",
    on_payload_received=on_payload_received
)
----

---

== Relay

The `Relay` component controls a relay module through a GPIO output.
It can be driven manually or via frames (slug).

=== Wiring

|===
| ESP32 Pin | Relay Pin

| GPIO (ex: GPIO27)
| IN (control input)

| 5V / 3.3V
| VCC (depending on relay module)

| GND
| GND
|===

IMPORTANT:
* Ensure common ground between ESP32 and relay module.
* Many relay boards are **active-low** (IN=0 energizes relay). This component assumes:
** `open()` -> `pin.value(0)`
** `close()` -> `pin.value(1)`

=== Usage

[,python]
----
from src.components.relay import Relay
from src.utils.gpio import GPIO

relay = Relay(pin=GPIO.GPIO27)

relay.open()
relay.close()
relay.toggle()
----

=== Behavior

|===
| Action | Description

| `open()`
| Sets GPIO to `0` and sets `is_open = True`

| `close()`
| Sets GPIO to `1` and sets `is_open = False`

| `toggle()`
| Opens if closed, closes if open
|===

=== Frame-based control (optional)

[,python]
----
relay = Relay(
    pin=GPIO.GPIO27,
    slug="door-relay"
)
----

Default behavior when a matching payload is received:

* if `payload.datatype == "bool"`:
** `True` -> `relay.open()`
** `False` -> `relay.close()`

Override behavior with a callback:

[,python]
----
def on_payload_received(relay, payload):
    # Example: toggle on True
    if payload.datatype == "bool" and payload.value:
        relay.toggle()

relay = Relay(
    pin=GPIO.GPIO27,
    slug="door-relay",
    on_payload_received=on_payload_received
)
----

=== State

|===
| Property | Description

| `is_open`
| `True` when relay is open, else `False`
|===

---

== Engine

The `Engine` component is a generic digital output controller (similar to `Led`)
with an optional frame binding via `slug`.

It is suitable for driving a transistor, MOSFET, motor driver input, etc.
(Do not drive motors directly from a GPIO.)

=== Wiring

|===
| ESP32 Pin | Engine Driver Pin

| GPIO (ex: GPIO14)
| Control input of the driver (IN / EN)

| GND
| Driver ground (common ground required)
|===

IMPORTANT:
* Always use a proper driver (transistor/MOSFET/module) for real loads.
* This component uses `Pin.OUT` with `Pin.PULL_DOWN`.

=== Usage

[,python]
----
from src.components.engine import Engine
from src.utils.gpio import GPIO

engine = Engine(pin=GPIO.GPIO14)

engine.on()
engine.off()
----

=== Frame-based control (optional)

[,python]
----
engine = Engine(
    pin=GPIO.GPIO14,
    slug="fan"
)
----

Default behavior when a matching payload is received:

* if `payload.datatype == "bool"`:
** `True` -> `engine.on()`
** `False` -> `engine.off()`

Override behavior with a callback:

[,python]
----
def on_payload_received(engine, payload):
    # Example: safety: ignore OFF frames
    if payload.datatype == "bool" and payload.value:
        engine.on()

engine = Engine(
    pin=GPIO.GPIO14,
    slug="fan",
    on_payload_received=on_payload_received
)
----

=== State

|===
| Property | Description

| `is_on`
| `True` when output is on, else `False`
|===

---

== Encoder

The `Encoder` component listens to a rotary encoder (quadrature A/B).

It is designed for precision:
* It captures A/B transitions using GPIO interrupts (IRQ) so no steps are missed.
* It dispatches callbacks through the application update loop (`App().update`)
  to keep IRQ handlers lightweight/safe.

=== Wiring

A rotary encoder exposes two signals: `A` and `B` (sometimes labeled `CLK` and `DT`).
Some encoder boards also provide `VCC` and `GND`.

|===
| ESP32 Pin | Encoder Pin

| GPIO (ex: GPIO25)
| Signal A

| GPIO (ex: GPIO26)
| Signal B

| 3.3V
| VCC (recommended)

| GND
| GND
|===

IMPORTANT:
* Use **3.3V** for VCC to avoid 5V levels on ESP32 GPIOs.
* Ensure common ground.
* If your encoder board already contains pull resistors, internal pulls may still work.
  External 10k pull-ups can improve stability on noisy setups.

NOTE: The component uses `PULL_UP` by default.

=== Usage

[,python]
----
from src.components.encoder import Encoder
from src.utils.gpio import GPIO

encoder = Encoder(
    pinA=GPIO.GPIO25,
    pinB=GPIO.GPIO26,
    onCw=lambda: print("CW"),
    onCcw=lambda: print("CCW"),
    onChange=lambda pos, delta: print("pos:", pos, "delta:", delta)
)
----

=== Behavior

The encoder produces multiple electrical transitions per physical “click” (detent).
The component accumulates transitions and emits one step per detent.

|===
| Event | Description

| `onCw`
| Called once per detent when rotating clockwise

| `onCcw`
| Called once per detent when rotating counter-clockwise

| `onChange(position, delta)`
| Called once per detent. `position` is the updated position, `delta` is the signed step count.
|===

=== Configuration

|===
| Parameter | Description | Default

| `pull`
| GPIO pull mode for A/B inputs (`Pin.PULL_UP` or `Pin.PULL_DOWN`) | `Pin.PULL_UP`

| `steps_per_detent`
| Number of valid quadrature transitions required to count one detent | `4`

| `min_us`
| Debounce filter in microseconds (ignore edges too close in time) | `150`
|===

Tips:
* If you see occasional wrong direction steps, increase `min_us` (e.g. 250–400).
* If you miss steps while rotating fast, decrease `min_us` (e.g. 80–120).
* `position` is stored as an integer and can be reset with `reset()`.

=== State

|===
| Property | Description

| `position`
| Current encoder position (in detents)
|===

---

== DHTSensor (DHT22)

The `DHTSensor` component reads temperature and humidity from a DHT22 (AM2302) sensor module.
It periodically polls the sensor and dispatches callbacks through the application update loop
(`App().update`).

=== Wiring

DHT22 module (3 pins), **pins on the left**, sensor facing you:

[source,text]
----
┌───────────────┐
│   DHT22       │
│               │
│  [S]  SIGNAL  │  ← DATA
│  [+]  5V/3.3V │  ← VCC
│  [-]  GND     │  ← GND
└───────────────┘
----

|===
| ESP32 Pin | DHT22 Module Pin

| GPIO (ex: GPIO4)
| SIGNAL (S)

| 3.3V
| VCC (+)

| GND
| GND (-)
|===

IMPORTANT:
* Always power the DHT22 module with **3.3V** when using an ESP32.
* Ensure common ground between ESP32 and the sensor.
* Do not read the sensor more than once every ~2 seconds.

=== Usage

[,python]
----
from src.components.dht_sensor import DHTSensor
from src.utils.gpio import GPIO

sensor = DHTSensor(
    pin=GPIO.GPIO4,
    onChange=lambda t, h: print("T:", t, "H:", h),
    onTemperatureChange=lambda t: print("Temperature:", t),
    onHumidityChange=lambda h: print("Humidity:", h)
)
----

=== Behavior

The sensor is polled periodically (default ~2.5s).
Callbacks are triggered only when values change.

|===
| Event | Description

| `onTemperatureChange`
| Called when the temperature value changes

| `onHumidityChange`
| Called when the humidity value changes

| `onChange`
| Called when either temperature or humidity changes
|===

=== Notes

* Temperature is expressed in **°C**
* Humidity is expressed in **%**
* Internally uses the MicroPython `dht.DHT22` driver
* Errors (timeouts) are silently ignored and retried on next update

=== State

|===
| Property | Description

| `temperature`
| Last measured temperature (°C)

| `humidity`
| Last measured humidity (%)
|===

---

== MCP3008

The `MCP3008` component is a SPI-based 8-channel analog-to-digital converter (ADC).
It allows the ESP32 to read analog voltages from up to 8 independent channels.
It automatically registers itself in the application update loop (`App().update`).

=== Wiring

The MCP3008 is a 16-pin DIP integrated circuit. Pin layout (with sensor facing you):

[source,text]
----
           ┌─────────┐
       CH0 ┤1      16├ VDD (3.3V)
       CH1 ┤2      15├ VREF (3.3V)
       CH2 ┤3      14├ AGND (GND)
       CH3 ┤4      13├ CLK (SCK)
       CH4 ┤5      12├ DOUT (MISO)
       CH5 ┤6      11├ DIN (MOSI)
       CH6 ┤7      10├ CS
       CH7 ┤8       9├ DGND (GND)
           └─────────┘
----

|===
| MCP3008 Pin | ESP32 Pin | Description

| VDD (16)
| 3.3V
| Power supply

| VREF (15)
| 3.3V
| Analog reference voltage

| AGND (14)
| GND
| Analog ground

| DGND (9)
| GND
| Digital ground

| CLK (13)
| GPIO 18 (default)
| SPI Clock (SCK)

| DIN (11)
| GPIO 23 (default)
| SPI Master Out Slave In (MOSI)

| DOUT (12)
| GPIO 19 (default)
| SPI Master In Slave Out (MISO)

| CS (10)
| GPIO 5 (default)
| Chip Select (active low)

| CH0–CH7 (1–8)
| Analog inputs
| Input voltage: 0V to VREF (0V to 3.3V)
|===

IMPORTANT:
* Ensure common ground between ESP32 and MCP3008.
* VREF and AGND should be at the same potential as the ESP32 3.3V and GND for single-ended measurements.
* The MCP3008 reads analog voltages in the range 0V to VREF and converts them to 10-bit digital values (0–1023).
* Do not exceed 3.3V on any analog input channel.

=== Usage

[,python]
----
from src.components.mcp3008 import MCP3008, Chanel
from src.utils.gpio import GPIO

# Define channels
ch0 = Chanel(pin=0, name="sensor-0", on_value=lambda: print("CH0 updated"))
ch1 = Chanel(pin=1, name="sensor-1")

# Create MCP3008 with channels
adc = MCP3008(
    chanels=[ch0, ch1],
    cs=GPIO.GPIO5,
    sck=GPIO.GPIO18,
    mosi=GPIO.GPIO23,
    miso=GPIO.GPIO19,
    vspi=2,
    bauds=1_000_000,
    read_delay=20  # milliseconds
)
----

=== Configuration

|===
| Parameter | Description | Default

| `chanels`
| List of `Chanel` objects to read
| `[]`

| `cs`
| GPIO pin for Chip Select
| `5`

| `sck`
| GPIO pin for SPI Clock
| `18`

| `mosi`
| GPIO pin for MOSI (Master Out Slave In)
| `23`

| `miso`
| GPIO pin for MISO (Master In Slave Out)
| `19`

| `vspi`
| SPI host (0=HSPI, 1=VSPI for ESP32)
| `2` (VSPI)

| `bauds`
| SPI baud rate in bits per second
| `1_000_000` (1 MHz)

| `polarity`
| SPI clock polarity (0 or 1)
| `0`

| `phase`
| SPI clock phase (0 or 1)
| `0`

| `read_delay`
| Polling interval in milliseconds
| `20`
|===

=== Chanel (sic) Class

The `Chanel` class represents a single ADC input channel.

|===
| Parameter | Description | Default

| `pin`
| Channel number (0–7) on the MCP3008
| Required

| `name`
| Descriptive name for debugging
| Required

| `on_value`
| Optional callback function called when the channel is read
| `None`
|===

=== Behavior

* The MCP3008 polls all configured channels at the specified `read_delay` interval.
* For each channel, the raw ADC value (0–1023) is read via SPI.
* If an `on_value` callback is defined for a `Chanel`, it is invoked after reading.
* In debug mode (`App().DEBUG == True`), each read is printed: `MCP Chanel {name}: {value}`.

=== Technical Details

* **Resolution**: 10-bit (0–1023)
* **Conversion Time**: ~3 µs per channel read
* **Input Impedance**: ~100 kΩ (typical)
* **SPI Protocol**: Single-ended, single conversion mode
  - Command byte: `0x01` (start bit)
  - Configuration byte: `0x80 | (channel << 4)` (single-ended mode + channel select)
  - Output bytes: Clock out the result

For additional details, refer to the https://cdn-shop.adafruit.com/datasheets/MCP3008.pdf[MCP3008 datasheet].

=== Notes

* Channel numbering is 0–7 (not 1–8).
* Ensure stable power and decoupling capacitors (0.1 µF) near VDD and VREF for best results.
* If readings are noisy, increase the `read_delay` or add external capacitors on the analog inputs.
* The component does not perform any filtering; consider adding low-pass RC filters for analog signals if needed.