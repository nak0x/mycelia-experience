= ESP32 Components documentation
:toc:
:toclevels: 3

WARNING: This documentation describes the current behavior of ESP32 components.
Internal APIs or hooks may evolve in the future.

== Conventions

=== GPIO constants
Most examples assume you use a `GPIO` helper enum/constants, e.g. `GPIO.GPIO32`.
Replace with raw pin numbers if your project does not use this helper.

=== Application hooks
Components register themselves to the framework in one of these lists:

* `App().update` for components that need periodic polling/dispatch in the main loop
* `App().on_frame_received` for components that react to incoming frames

=== Frames and slugs
Some components can be bound to incoming frame payloads via a `slug`.

* If `slug` is `None`, the component ignores frames.
* If `slug` is set, the component scans `frame.payload` and reacts when `payload.slug == slug`.
* If `on_payload_received` is provided, it is called first and you can override the default behavior.

Callback signature:
[,python]
----
def on_payload_received(component, payload):
    ...
----

---

== Button

The `Button` component listens to a physical button connected to a GPIO pin.
It automatically registers itself in the application update loop (`App().update`).

=== Wiring

|===
| ESP32 Pin | Button Pin

| GPIO (ex: GPIO32)
| One side of the button

| GND
| Other side of the button
|===

IMPORTANT: The button uses an internal `PULL_DOWN` resistor.
This means the GPIO reads `0` when released, and must be connected to **3.3V** when pressed
(e.g. button between GPIO and 3.3V, NOT between GPIO and GND).

=== Usage

[,python]
----
from src.components.button import Button
from src.utils.gpio import GPIO

button = Button(
    pin=GPIO.GPIO32,
    onPress=lambda: print("Button pressed"),
    onRelease=lambda: print("Button released")
)
----

=== Behavior

|===
| Event | Description

| `onPress`
| Called once when the button transitions from released to pressed

| `onRelease`
| Called once when the button transitions from pressed to released
|===

---

== Led

The `Led` component controls a single digital LED using a GPIO output.
It can also react to incoming frames if a `slug` is provided.

=== Wiring

|===
| ESP32 Pin | LED Pin

| GPIO (ex: GPIO2)
| LED anode (through a resistor)

| GND
| LED cathode
|===

IMPORTANT: Always use a current-limiting resistor (typically 220Ω – 330Ω).

=== Usage

[,python]
----
from src.components.led import Led
from src.utils.gpio import GPIO

led = Led(
    pin=GPIO.GPIO2
)

led.on()
led.off()
----

=== Frame-based control (optional)

If a `slug` is provided, the LED reacts automatically to incoming frames.

[,python]
----
led = Led(
    pin=GPIO.GPIO2,
    slug="status-led"
)
----

Default behavior when a matching payload is received:

* if `payload.datatype == "bool"`:
** `True` -> `led.on()`
** `False` -> `led.off()`

Override behavior with a callback:

[,python]
----
def on_payload_received(led, payload):
    # Example: invert logic
    if payload.datatype == "bool":
        led.off() if payload.value else led.on()

led = Led(
    pin=GPIO.GPIO2,
    slug="status-led",
    on_payload_received=on_payload_received
)
----

=== State

|===
| Property | Description

| `is_on`
| `True` when the LED is currently on, else `False`
|===

---

== LedStrip

The `LedStrip` component controls an addressable LED strip (NeoPixel / WS2812).
It listens to incoming frames to toggle the strip state.

=== Wiring

|===
| ESP32 Pin | Led Strip Pin

| GPIO (ex: GPIO25)
| DIN (Data In)

| 5V / 3.3V
| VCC (depending on strip model)

| GND
| GND
|===

IMPORTANT:
* Ensure common ground between ESP32 and the LED strip.
* Some strips require an external 5V power supply.
* Some 5V strips may require a level shifter on the data line for reliable operation.

=== Usage

[,python]
----
from src.components.led_strip import LedStrip
from src.utils.gpio import GPIO

strip = LedStrip(
    pin=GPIO.GPIO25,
    pixel_num=10
)

strip.on()      # fill with default color
strip.off()     # clear
strip.set_pixel(0, (255, 0, 0), show=True)
----

=== Default behavior

|===
| Action | Description

| `on(color=None)`
| Turns all pixels on using `color` or `default_color`

| `off()`
| Turns all pixels off (clears strip)

| `fill(color)`
| Updates internal pixels array (does not automatically show)

| `display()`
| Writes internal pixels array to the strip

| `set_pixel(i, color=None, show=False)`
| Sets one pixel to `color` (or default) and optionally displays

| `next_pixel(color=None, show=False)`
| Lights the next pixel with the given color (or default) and returns its index

| `previous_pixel(color=None, show=False)`
| Lights the previous pixel with the given color (or default) and returns its index
|===

=== Frame-based control (optional)

Bind the strip to a frame payload using a `slug`.

[,python]
----
strip = LedStrip(
    pin=GPIO.GPIO25,
    pixel_num=10,
    slug="main-strip"
)
----

Default behavior when a matching payload is received:

* if `payload.datatype == "bool"`:
** `True` -> `strip.on()`
** `False` -> `strip.off()`

Override behavior with a callback:

[,python]
----
def on_payload_received(strip, payload):
    # Example: change color based on a custom payload
    if payload.datatype == "bool":
        strip.on((0, 255, 0)) if payload.value else strip.off()

strip = LedStrip(
    pin=GPIO.GPIO25,
    pixel_num=10,
    slug="main-strip",
    on_payload_received=on_payload_received
)
----

---

== Relay

The `Relay` component controls a relay module through a GPIO output.
It can be driven manually or via frames (slug).

=== Wiring

|===
| ESP32 Pin | Relay Pin

| GPIO (ex: GPIO27)
| IN (control input)

| 5V / 3.3V
| VCC (depending on relay module)

| GND
| GND
|===

IMPORTANT:
* Ensure common ground between ESP32 and relay module.
* Many relay boards are **active-low** (IN=0 energizes relay). This component assumes:
** `open()` -> `pin.value(0)`
** `close()` -> `pin.value(1)`

=== Usage

[,python]
----
from src.components.relay import Relay
from src.utils.gpio import GPIO

relay = Relay(pin=GPIO.GPIO27)

relay.open()
relay.close()
relay.toggle()
----

=== Behavior

|===
| Action | Description

| `open()`
| Sets GPIO to `0` and sets `is_open = True`

| `close()`
| Sets GPIO to `1` and sets `is_open = False`

| `toggle()`
| Opens if closed, closes if open
|===

=== Frame-based control (optional)

[,python]
----
relay = Relay(
    pin=GPIO.GPIO27,
    slug="door-relay"
)
----

Default behavior when a matching payload is received:

* if `payload.datatype == "bool"`:
** `True` -> `relay.open()`
** `False` -> `relay.close()`

Override behavior with a callback:

[,python]
----
def on_payload_received(relay, payload):
    # Example: toggle on True
    if payload.datatype == "bool" and payload.value:
        relay.toggle()

relay = Relay(
    pin=GPIO.GPIO27,
    slug="door-relay",
    on_payload_received=on_payload_received
)
----

=== State

|===
| Property | Description

| `is_open`
| `True` when relay is open, else `False`
|===

---

== Engine

The `Engine` component is a generic digital output controller (similar to `Led`)
with an optional frame binding via `slug`.

It is suitable for driving a transistor, MOSFET, motor driver input, etc.
(Do not drive motors directly from a GPIO.)

=== Wiring

|===
| ESP32 Pin | Engine Driver Pin

| GPIO (ex: GPIO14)
| Control input of the driver (IN / EN)

| GND
| Driver ground (common ground required)
|===

IMPORTANT:
* Always use a proper driver (transistor/MOSFET/module) for real loads.
* This component uses `Pin.OUT` with `Pin.PULL_DOWN`.

=== Usage

[,python]
----
from src.components.engine import Engine
from src.utils.gpio import GPIO

engine = Engine(pin=GPIO.GPIO14)

engine.on()
engine.off()
----

=== Frame-based control (optional)

[,python]
----
engine = Engine(
    pin=GPIO.GPIO14,
    slug="fan"
)
----

Default behavior when a matching payload is received:

* if `payload.datatype == "bool"`:
** `True` -> `engine.on()`
** `False` -> `engine.off()`

Override behavior with a callback:

[,python]
----
def on_payload_received(engine, payload):
    # Example: safety: ignore OFF frames
    if payload.datatype == "bool" and payload.value:
        engine.on()

engine = Engine(
    pin=GPIO.GPIO14,
    slug="fan",
    on_payload_received=on_payload_received
)
----

=== State

|===
| Property | Description

| `is_on`
| `True` when output is on, else `False`
|===

---

== Encoder

The `Encoder` component listens to a rotary encoder (quadrature A/B).

It is designed for precision:
* It captures A/B transitions using GPIO interrupts (IRQ) so no steps are missed.
* It dispatches callbacks through the application update loop (`App().update`)
  to keep IRQ handlers lightweight/safe.

=== Wiring

A rotary encoder exposes two signals: `A` and `B` (sometimes labeled `CLK` and `DT`).
Some encoder boards also provide `VCC` and `GND`.

|===
| ESP32 Pin | Encoder Pin

| GPIO (ex: GPIO25)
| Signal A

| GPIO (ex: GPIO26)
| Signal B

| 3.3V
| VCC (recommended)

| GND
| GND
|===

IMPORTANT:
* Use **3.3V** for VCC to avoid 5V levels on ESP32 GPIOs.
* Ensure common ground.
* If your encoder board already contains pull resistors, internal pulls may still work.
  External 10k pull-ups can improve stability on noisy setups.

NOTE: The component uses `PULL_UP` by default.

=== Usage

[,python]
----
from src.components.encoder import Encoder
from src.utils.gpio import GPIO

encoder = Encoder(
    pinA=GPIO.GPIO25,
    pinB=GPIO.GPIO26,
    onCw=lambda: print("CW"),
    onCcw=lambda: print("CCW"),
    onChange=lambda pos, delta: print("pos:", pos, "delta:", delta)
)
----

=== Behavior

The encoder produces multiple electrical transitions per physical “click” (detent).
The component accumulates transitions and emits one step per detent.

|===
| Event | Description

| `onCw`
| Called once per detent when rotating clockwise

| `onCcw`
| Called once per detent when rotating counter-clockwise

| `onChange(position, delta)`
| Called once per detent. `position` is the updated position, `delta` is the signed step count.
|===

=== Configuration

|===
| Parameter | Description | Default

| `pull`
| GPIO pull mode for A/B inputs (`Pin.PULL_UP` or `Pin.PULL_DOWN`) | `Pin.PULL_UP`

| `steps_per_detent`
| Number of valid quadrature transitions required to count one detent | `4`

| `min_us`
| Debounce filter in microseconds (ignore edges too close in time) | `150`
|===

Tips:
* If you see occasional wrong direction steps, increase `min_us` (e.g. 250–400).
* If you miss steps while rotating fast, decrease `min_us` (e.g. 80–120).
* `position` is stored as an integer and can be reset with `reset()`.

=== State

|===
| Property | Description

| `position`
| Current encoder position (in detents)
|===

---

== DHTSensor (DHT22)

The `DHTSensor` component reads temperature and humidity from a DHT22 (AM2302) sensor module.
It periodically polls the sensor and dispatches callbacks through the application update loop
(`App().update`).

=== Wiring

DHT22 module (3 pins), **pins on the left**, sensor facing you:

[source,text]
----
┌───────────────┐
│   DHT22       │
│               │
│  [S]  SIGNAL  │  ← DATA
│  [+]  5V/3.3V │  ← VCC
│  [-]  GND     │  ← GND
└───────────────┘
----

|===
| ESP32 Pin | DHT22 Module Pin

| GPIO (ex: GPIO4)
| SIGNAL (S)

| 3.3V
| VCC (+)

| GND
| GND (-)
|===

IMPORTANT:
* Always power the DHT22 module with **3.3V** when using an ESP32.
* Ensure common ground between ESP32 and the sensor.
* Do not read the sensor more than once every ~2 seconds.

=== Usage

[,python]
----
from src.components.dht_sensor import DHTSensor
from src.utils.gpio import GPIO

sensor = DHTSensor(
    pin=GPIO.GPIO4,
    onChange=lambda t, h: print("T:", t, "H:", h),
    onTemperatureChange=lambda t: print("Temperature:", t),
    onHumidityChange=lambda h: print("Humidity:", h)
)
----

=== Behavior

The sensor is polled periodically (default ~2.5s).
Callbacks are triggered only when values change.

|===
| Event | Description

| `onTemperatureChange`
| Called when the temperature value changes

| `onHumidityChange`
| Called when the humidity value changes

| `onChange`
| Called when either temperature or humidity changes
|===

=== Notes

* Temperature is expressed in **°C**
* Humidity is expressed in **%**
* Internally uses the MicroPython `dht.DHT22` driver
* Errors (timeouts) are silently ignored and retried on next update

=== State

|===
| Property | Description

| `temperature`
| Last measured temperature (°C)

| `humidity`
| Last measured humidity (%)
|===